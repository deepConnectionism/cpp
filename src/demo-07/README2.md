# ä½ çš„çº¿ç¨‹æ± å°±æ˜¯ä¸€ä¸ªæ ‡å‡† åº“å½¢å¼ çš„æ¨¡å—äº†ï¼Œå…¶ä»–ç®—æ³•é¡¹ç›®ä¹Ÿèƒ½ç›´æ¥å¼•å…¥ã€‚è¿™ä¸ªæ€ä¹ˆç†è§£å‘¢ï¼Ÿ

ğŸ‘Œ è¿™ä¸ªé—®é¢˜é—®å¾—å¾ˆåˆ°ä½ï¼Œä½ å·²ç»åœ¨æ€è€ƒ **å·¥ç¨‹åŒ– + å¤ç”¨** äº†ã€‚
æˆ‘è¯´â€œä½ çš„çº¿ç¨‹æ± å°±æ˜¯ä¸€ä¸ªæ ‡å‡†åº“å½¢å¼çš„æ¨¡å—â€æ˜¯æƒ³å¼ºè°ƒï¼š

---

## ğŸ” 1. â€œåº“â€æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨ C++ é‡Œï¼Œâ€œåº“â€å°±æ˜¯ä¸€æ®µ**å¯å¤ç”¨çš„ä»£ç **ï¼Œåˆ«äººï¼ˆæˆ–ä½ è‡ªå·±ï¼‰å¯ä»¥åœ¨ä¸åŒé¡¹ç›®é‡Œç›´æ¥ç”¨ï¼Œè€Œä¸ç”¨é‡å¤å†™ã€‚

* **æ ‡å‡†åº“ STL**ï¼š`std::vector`, `std::thread`, `std::mutex`â€¦
* **ç¬¬ä¸‰æ–¹åº“**ï¼šBoost, OpenCV, Eigenâ€¦
* **ä½ å†™çš„çº¿ç¨‹æ± **ï¼šåªè¦è®¾è®¡æˆ **æ¥å£æ¸…æ™° + å®ç°å°è£…**ï¼Œå…¶å®å°±å¯ä»¥åƒâ€œåº“â€ä¸€æ ·ç”¨äº†ã€‚

---

## ğŸ” 2. æ¨¡å—åŒ–çš„ç‰¹ç‚¹

çº¿ç¨‹æ± è¢«æŠ½è±¡æˆä¸€ä¸ª **ç±»ï¼ˆThreadPoolï¼‰**ï¼Œå®ƒçš„ä½¿ç”¨æ–¹å¼å°±å¾ˆâ€œæ ‡å‡†â€ï¼š

* **æä¾›æ¥å£**ï¼š`submit(task)`
* **éšè—ç»†èŠ‚**ï¼šç”¨æˆ·ä¸éœ€è¦ç®¡ `mutex`ã€`condition_variable`ã€`queue` çš„ç»†èŠ‚ã€‚
* **å¯å¤ç”¨**ï¼šä»»ä½•åœ°æ–¹éœ€è¦å¤šçº¿ç¨‹ï¼Œå°±å¯ä»¥ç›´æ¥ `#include "ThreadPool.h"`ï¼Œä¸ç”¨å†å†™ä¸€éã€‚

---

## ğŸ” 3. ä¸ºä»€ä¹ˆè¯´â€œå…¶ä»–ç®—æ³•é¡¹ç›®ä¹Ÿèƒ½ç›´æ¥å¼•å…¥â€ï¼Ÿ

å‡è®¾ä½ æœ‰ä¸¤ä¸ªé¡¹ç›®ï¼š

* é¡¹ç›® Aï¼šå›¾åƒå¤„ç†ç®—æ³•ï¼ˆéœ€è¦å¹¶è¡Œå¤„ç†å¤šå¼ å›¾ï¼‰ã€‚
* é¡¹ç›® Bï¼šå›¾æœç´¢ç®—æ³•ï¼ˆéœ€è¦å¹¶å‘æ‰©å±•èŠ‚ç‚¹ï¼‰ã€‚

ä¼ ç»Ÿåšæ³•ï¼šæ¯ä¸ªé¡¹ç›®é‡Œéƒ½å†™ä¸€é **çº¿ç¨‹ç®¡ç†é€»è¾‘**ï¼ˆé”ã€é˜Ÿåˆ—ã€æ¡ä»¶å˜é‡ â†’ å¾ˆå†—ä½™ï¼‰ã€‚
ç°åœ¨ï¼š

* ä½ åªéœ€è¦æŠŠ `include/ThreadPool.h` å’Œ `src/ThreadPool.cpp` æ‹·è´åˆ°æ–°é¡¹ç›®ã€‚
* åœ¨ `main.cpp` æˆ–ç®—æ³•ä»£ç é‡Œï¼š

  ```cpp
  #include "ThreadPool.h"
  ```

  ç„¶åç›´æ¥ç”¨ï¼š

  ```cpp
  ThreadPool pool(8);
  auto result = pool.submit(myAlgorithm, param1, param2);
  ```

å°±è·Ÿè°ƒç”¨ `std::thread` ä¸€æ ·æ–¹ä¾¿ã€‚
ğŸ‘‰ è¿™å°±æ˜¯â€œæ¨¡å—åŒ–ã€åº“åŒ–â€çš„æ„ä¹‰ã€‚

---

## ğŸ” 4. ä¸¾ä¸ªç”Ÿæ´»ä¾‹å­

* å¦‚æœä½ å†™çš„çº¿ç¨‹æ± åªæ˜¯å†™åœ¨ `main.cpp`ï¼Œé‚£å®ƒåªèƒ½åœ¨è¿™ä¸ª demo ç”¨ï¼Œåˆ«äººæ²¡æ³•ç”¨ã€‚
* å¦‚æœä½ æŠŠå®ƒå°è£…å¥½ï¼Œå°±åƒé€ äº†ä¸€å°â€œé€šç”¨æœºå™¨â€ â†’ ä»¥åæ— è®ºæ˜¯å›¾åƒã€æœç´¢ã€è®­ç»ƒæ•°æ®ï¼Œç›´æ¥è°ƒç”¨ `ThreadPool` å°±èƒ½å¹¶è¡Œå¤„ç†ã€‚

å°±å¥½æ¯”ï¼š

* â€œèºä¸åˆ€â€ â†’ ä½ æ¯æ¬¡éƒ½ç°åœºæ‰“ç£¨ï¼ˆé‡å¤åŠ³åŠ¨ï¼‰ã€‚
* â€œå·¥å…·ç®±â€ â†’ ä½ åšäº†ä¸€æŠŠèºä¸åˆ€ï¼ˆçº¿ç¨‹æ± ç±»ï¼‰ï¼Œä»¥åå®¶é‡Œæ¢ç¯æ³¡ã€ç»„è£…å®¶å…·éƒ½èƒ½ç”¨ã€‚

---

## ğŸ”‘ æ€»ç»“

â€œä½ çš„çº¿ç¨‹æ± æ˜¯ä¸€ä¸ªæ ‡å‡†åº“å½¢å¼çš„æ¨¡å—â€ =

1. **æ¥å£æ¸…æ™°ï¼ˆsubmit / æ„é€  / ææ„ï¼‰**
2. **å®ç°å°è£…ï¼ˆé”ã€é˜Ÿåˆ—ã€æ¡ä»¶å˜é‡å¯¹å¤–ä¸å¯è§ï¼‰**
3. **å¯å¤ç”¨ï¼ˆä»»ä½•ç®—æ³•é¡¹ç›®ç›´æ¥ include å°±èƒ½ç”¨ï¼‰**

---

è¦ä¸è¦æˆ‘å¸®ä½ æ¼”ç¤ºä¸€ä¸‹ï¼š

* åœ¨ä¸€ä¸ªâ€œå›¾åƒå¤„ç†é¡¹ç›®â€é‡Œå¦‚ä½•ç”¨è¿™ä¸ªçº¿ç¨‹æ± åŠ é€Ÿï¼Ÿ
* åœ¨ä¸€ä¸ªâ€œå›¾æœç´¢é¡¹ç›®â€é‡Œå¦‚ä½•ç”¨è¿™ä¸ªçº¿ç¨‹æ± å¹¶è¡Œæ‰©å±•ï¼Ÿ

è¿™æ ·ä½ å°±èƒ½ç›´è§‚æ„Ÿå—åˆ°â€œåŒä¸€ä¸ªåº“æ¨¡å— â†’ ä¸åŒç®—æ³•åœºæ™¯å¤ç”¨â€ã€‚

# åœ¨ä¸€ä¸ªâ€œå›¾åƒå¤„ç†é¡¹ç›®â€é‡Œå¦‚ä½•ç”¨è¿™ä¸ªçº¿ç¨‹æ± åŠ é€Ÿï¼Ÿ

å¥½é—®é¢˜ ğŸš€ï¼
æˆ‘ä»¬æ¥åšä¸€ä¸ªå°å®éªŒï¼Œçœ‹çœ‹ **çº¿ç¨‹æ± åœ¨å›¾åƒå¤„ç†é¡¹ç›®é‡Œæ€ä¹ˆåŠ é€Ÿ**ã€‚æˆ‘ç”¨ OpenCV ä¸¾ä¾‹ï¼ˆå‡è®¾ä½ ä¼šç”¨/å¯ä»¥è£…ï¼‰ï¼Œå¦‚æœæ²¡æœ‰ OpenCV ä¹Ÿå¯ä»¥æŠŠå®ƒçœ‹ä½œâ€œæ¨¡æ‹Ÿå›¾åƒå¤„ç†å‡½æ•°â€ã€‚

---

## ğŸ–¼ï¸ åœºæ™¯ï¼šæ‰¹é‡å›¾åƒå¤„ç†

* ä½ æœ‰ä¸€ä¸ªç›®å½•ï¼Œé‡Œé¢æœ‰å¾ˆå¤šå¼ å›¾ç‰‡ï¼ˆå‡ ç™¾å¼  JPGï¼‰ã€‚
* ä½ éœ€è¦å¯¹æ¯å¼ å›¾ç‰‡åšä¸€äº›æ“ä½œï¼Œæ¯”å¦‚ï¼šç°åº¦åŒ– / é«˜æ–¯æ¨¡ç³Š / è¾¹ç¼˜æ£€æµ‹ã€‚
* **å•çº¿ç¨‹å¤„ç†**ï¼šä¸€å¼ å¼ é¡ºåºå¤„ç†ï¼Œå¾ˆæ…¢ã€‚
* **çº¿ç¨‹æ± åŠ é€Ÿ**ï¼šå¼€ 8 ä¸ª worker çº¿ç¨‹ï¼ŒåŒæ—¶å¤„ç† 8 å¼ å›¾ã€‚

---

## ğŸ§ª ä»£ç ç¤ºä¾‹

### ImageProcessor.h

```cpp
#pragma once
#include <opencv2/opencv.hpp>
#include <string>

// ç®€å•çš„å›¾åƒå¤„ç†å‡½æ•°ï¼ˆç°åº¦ + é«˜æ–¯æ¨¡ç³Šï¼‰
cv::Mat processImage(const std::string& filename) {
    cv::Mat img = cv::imread(filename);
    if (img.empty()) return img;

    cv::Mat gray, blur;
    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);
    cv::GaussianBlur(gray, blur, cv::Size(5,5), 1.5);

    return blur;
}
```

---

### main.cpp

```cpp
#include "ThreadPool.h"
#include "ImageProcessor.h"
#include <filesystem>
#include <iostream>
#include <vector>
#include <future>

namespace fs = std::filesystem;

int main() {
    ThreadPool pool(8);  // 8 ä¸ªå·¥ä½œçº¿ç¨‹

    std::string folder = "./images";
    std::vector<std::future<cv::Mat>> futures;

    // æ‰«ææ–‡ä»¶å¤¹ï¼Œæäº¤ä»»åŠ¡
    for (const auto& entry : fs::directory_iterator(folder)) {
        if (entry.is_regular_file()) {
            auto filepath = entry.path().string();
            futures.push_back(pool.submit(processImage, filepath));
        }
    }

    // æ”¶é›†ç»“æœ
    int idx = 0;
    for (auto& f : futures) {
        cv::Mat result = f.get();
        if (!result.empty()) {
            std::string outname = "./output/result_" + std::to_string(idx++) + ".png";
            cv::imwrite(outname, result);
            std::cout << "Saved " << outname << std::endl;
        }
    }

    std::cout << "All images processed!" << std::endl;
    return 0;
}
```

---

## âš¡ å·¥ä½œæµç¨‹

1. çº¿ç¨‹æ± åˆ›å»º 8 ä¸ª workerï¼ˆå›ºå®š 8 ä¸ªçº¿ç¨‹ï¼‰ã€‚
2. éå† `./images/` æ–‡ä»¶å¤¹ï¼Œæ¯å¼ å›¾ä¸€ä¸ªä»»åŠ¡ï¼Œä¸¢è¿›ä»»åŠ¡é˜Ÿåˆ—ã€‚
3. çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å¹¶å‘æ‰§è¡Œä»»åŠ¡ â†’ 8 å¼ å›¾åŒæ—¶å¤„ç†ã€‚
4. æœ€åç”¨ `future.get()` æ‹¿åˆ°ç»“æœï¼Œå¹¶å†™å…¥ç£ç›˜ã€‚

---

## ğŸ” åŠ é€Ÿæ•ˆæœ

* å¦‚æœå•çº¿ç¨‹å¤„ç†ä¸€å¼ å›¾è¦ 100msï¼Œ100 å¼ å›¾ = 10 ç§’ã€‚
* 8 çº¿ç¨‹å¹¶å‘æ—¶ï¼Œ100 å¼ å›¾ â‰ˆ 1.5 ç§’ï¼ˆè€ƒè™‘ IO + CPU å¼€é”€ï¼‰ã€‚
* æ•ˆæœï¼š**å‡ å€åˆ°åå‡ å€æé€Ÿ**ï¼Œç‰¹åˆ«æ˜¯ç®—æ³•æ–¹å‘ï¼ˆæ‰¹é‡ä»»åŠ¡å¾ˆå¸¸è§ï¼‰ã€‚

---

## ğŸ’¡ æ€»ç»“

* **çº¿ç¨‹æ± ** = å¾ˆé€‚åˆ **æ‰¹é‡ç‹¬ç«‹ä»»åŠ¡**ï¼ˆå›¾åƒå¤„ç†ã€æ•°æ®é¢„å¤„ç†ã€æ¨¡å‹è®­ç»ƒå‰çš„æ•°æ®å¢å¼ºï¼‰ã€‚
* **submit(task)** æäº¤ä»»åŠ¡ï¼Œä»»åŠ¡ä¹‹é—´äº’ä¸å¹²æ‰°ï¼Œéå¸¸é€‚åˆ CPU å¯†é›†å‹å’Œ IO å¯†é›†å‹å·¥ä½œã€‚

---

è¦ä¸è¦æˆ‘å†ç»™ä½ æ¼”ç¤ºä¸€ä¸ª **ç®—æ³•åœºæ™¯**ï¼ˆæ¯”å¦‚å¹¶è¡Œ BFS/DFS å›¾æœç´¢ï¼‰ï¼Œè¿™æ ·ä½ èƒ½å¯¹æ¯”â€œå›¾åƒå¤„ç†ä»»åŠ¡ vs ç®—æ³•ä»»åŠ¡â€åœ¨çº¿ç¨‹æ± é‡Œçš„ä¸åŒç”¨æ³•ï¼Ÿ

ğŸ‘Œ é‚£æˆ‘ä»¬å°±æ¥åšä¸€ä¸ª **ç®—æ³•åœºæ™¯ï¼šå¹¶è¡Œ BFS å›¾æœç´¢**ï¼Œå±•ç¤ºçº¿ç¨‹æ± æ€ä¹ˆå¸®ä½ åŠ é€Ÿã€‚

---

# ğŸ“˜ åœºæ™¯ï¼šå›¾æœç´¢ï¼ˆBFSï¼‰

* ä½ æœ‰ä¸€ä¸ªå¤§å›¾ï¼ˆæ¯”å¦‚çŠ¶æ€ç©ºé—´æœç´¢ã€æ£‹ç›˜èµ°æ³•æœç´¢ï¼‰ã€‚
* **å•çº¿ç¨‹ BFS**ï¼šé˜Ÿåˆ—é‡Œä¸€ä¸ªä¸ªèŠ‚ç‚¹å–å‡ºï¼Œæ‰©å±•å­èŠ‚ç‚¹ â†’ åŠ å…¥é˜Ÿåˆ—ã€‚
* **å¹¶è¡Œ BFS**ï¼šå¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰©å±•ä¸åŒèŠ‚ç‚¹ï¼Œèƒ½æ˜¾è‘—åŠ é€Ÿã€‚
* çº¿ç¨‹æ± ç”¨æ¥è´Ÿè´£â€œä»»åŠ¡è°ƒåº¦â€ï¼š

  * **ç”Ÿäº§è€…**ï¼šä¸»çº¿ç¨‹ä¸æ–­æŠŠâ€œå¾…æ‰©å±•çš„èŠ‚ç‚¹â€æäº¤ç»™çº¿ç¨‹æ± ã€‚
  * **æ¶ˆè´¹è€…**ï¼šçº¿ç¨‹æ± çš„ worker çº¿ç¨‹å»æ‰§è¡Œâ€œæ‰©å±•èŠ‚ç‚¹â€çš„é€»è¾‘ã€‚

---

# ğŸ§© ç¤ºä¾‹ä»£ç ï¼ˆç®€åŒ–ç‰ˆï¼‰

### Graph.h

```cpp
#pragma once
#include <vector>
#include <unordered_map>

class Graph {
public:
    std::unordered_map<int, std::vector<int>> adj;

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u); // æ— å‘å›¾
    }
};
```

---

### main.cpp

```cpp
#include "ThreadPool.h"
#include "Graph.h"
#include <iostream>
#include <future>
#include <queue>
#include <mutex>
#include <unordered_set>

int main() {
    Graph g;
    // æ„å»ºä¸€ä¸ªç®€å•å›¾
    for (int i = 0; i < 10; i++) {
        g.addEdge(i, (i + 1) % 10); // ç¯
    }
    g.addEdge(0, 5); // å¤šåŠ å‡ æ¡è¾¹
    g.addEdge(3, 7);

    int start = 0;
    int goal = 7;

    ThreadPool pool(4);
    std::queue<int> frontier;
    frontier.push(start);

    std::unordered_set<int> visited;
    visited.insert(start);

    std::mutex mtx;
    bool found = false;

    while (!frontier.empty() && !found) {
        int levelSize = frontier.size();
        std::vector<std::future<void>> futures;

        for (int i = 0; i < levelSize; i++) {
            int node = frontier.front();
            frontier.pop();

            // æäº¤æ‰©å±•ä»»åŠ¡
            futures.push_back(pool.submit([&g, node, goal, &visited, &mtx, &frontier, &found]() {
                for (int nei : g.adj[node]) {
                    std::lock_guard<std::mutex> lock(mtx);
                    if (found) return; // å·²ç»æ‰¾åˆ°ç›®æ ‡ï¼Œç›´æ¥è¿”å›

                    if (!visited.count(nei)) {
                        visited.insert(nei);
                        frontier.push(nei);
                        if (nei == goal) {
                            std::cout << "Found goal: " << goal << "\n";
                            found = true;
                        }
                    }
                }
            }));
        }

        // ç­‰å¾…è¿™ä¸€å±‚çš„ä»»åŠ¡å®Œæˆ
        for (auto &f : futures) f.get();
    }

    if (!found) {
        std::cout << "Goal not found\n";
    }
    return 0;
}
```

---

# ğŸ” å·¥ä½œæµç¨‹

1. BFS ä¸»å¾ªç¯é‡Œï¼Œæ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é€šè¿‡ `submit` æäº¤åˆ°çº¿ç¨‹æ± ã€‚
2. æ¯ä¸ª worker çº¿ç¨‹å¹¶è¡Œæ‰©å±•é‚»å±…èŠ‚ç‚¹ã€‚
3. ç”¨ `mutex` ä¿æŠ¤ **frontier é˜Ÿåˆ—** å’Œ **visited é›†åˆ**ã€‚
4. ä¸€æ—¦æ‰¾åˆ°ç›®æ ‡ `goal`ï¼Œæ ‡è®° `found = true`ï¼Œåç»­çº¿ç¨‹ä¸å†ç»§ç»­æ‰©å±•ã€‚

---

# âš¡ é€‚ç”¨åœºæ™¯

* çŠ¶æ€ç©ºé—´æœç´¢ï¼ˆä¾‹å¦‚ï¼š8 æ•°ç é—®é¢˜ã€æ£‹ç›˜èµ°æ³•ã€è·¯å¾„è§„åˆ’ï¼‰ã€‚
* å¤§è§„æ¨¡å›¾ï¼ˆç¤¾äº¤ç½‘ç»œã€çŸ¥è¯†å›¾è°±ï¼‰ä¸Šçš„æœç´¢ã€‚
* ç®—æ³•ç«èµ› / å·¥ä¸šåº”ç”¨é‡Œï¼Œèƒ½æ˜¾è‘—åŠ é€Ÿ BFS/DFSã€‚

---

ğŸ“Œ å¯¹æ¯” â€œå›¾åƒå¤„ç†é¡¹ç›®â€ï¼š

* **å›¾åƒå¤„ç†** â†’ æ¯å¼ å›¾ç‰‡ç‹¬ç«‹ï¼Œå¤©ç„¶å¹¶è¡Œã€‚
* **BFS æœç´¢** â†’ ä»»åŠ¡ä¹‹é—´æœ‰å…±äº«æ•°æ®ç»“æ„ï¼ˆfrontier / visitedï¼‰ï¼Œæ‰€ä»¥éœ€è¦ **é”** æ¥ä¿è¯æ­£ç¡®æ€§ã€‚

---

è¦ä¸è¦æˆ‘å†å¸®ä½ å‡çº§ä¸€ä¸‹è¿™ä¸ª BFSï¼Œæ¢æˆ **æ— é”å¹¶è¡Œé˜Ÿåˆ—ï¼ˆlock-free queueï¼‰** æ¥å‡å°‘é”å¼€é”€ï¼Ÿè¿™æ ·èƒ½æ›´è´´è¿‘çœŸå®å·¥ä¸šçº§å¹¶è¡Œæœç´¢çš„å®ç°ã€‚


å¥½ ğŸ‘Œï¼Œé‚£æˆ‘ä»¬æŠŠåˆšæ‰çš„ **å¹¶è¡Œ BFS** å‡çº§æˆä¸€ä¸ªæ›´é«˜æ•ˆçš„ç‰ˆæœ¬ â€”â€” ä½¿ç”¨ **æ— é”å¹¶è¡Œé˜Ÿåˆ— (lock-free queue)**ã€‚

åœ¨å›¾æœç´¢é‡Œï¼Œæœ€å¤§çš„ç“¶é¢ˆå°±æ˜¯ï¼š

* å¤šä¸ªçº¿ç¨‹è¦åŒæ—¶ **push / pop frontier é˜Ÿåˆ—**
* å¦‚æœç”¨ `std::mutex` é”ä¿æŠ¤ï¼Œä¼šé€ æˆä¸¥é‡çš„ **é”ç«äº‰**
* æ›´å¥½çš„åšæ³•æ˜¯ç”¨ **æ— é”é˜Ÿåˆ—**ï¼ˆåŸºäºåŸå­æ“ä½œ CASï¼‰

---

# ğŸ§© å®ç°æ€è·¯

æˆ‘ä»¬è‡ªå·±å®ç°ä¸€ä¸ªç®€åŒ–çš„ **æ— é”é˜Ÿåˆ—**ï¼ˆåŸºäº `std::atomic` + ç¯å½¢æ•°ç»„ï¼‰ï¼š

1. ç”¨ä¸€ä¸ªå›ºå®šå¤§å°çš„ **ç¯å½¢ç¼“å†²åŒº (ring buffer)** å­˜å‚¨èŠ‚ç‚¹ã€‚
2. ç”¨ä¸¤ä¸ªåŸå­å˜é‡ `head` å’Œ `tail` è¡¨ç¤ºè¯»å†™ä½ç½®ã€‚
3. ä½¿ç”¨ `compare_exchange_weak` ä¿è¯æ— é”çš„å…¥é˜Ÿå‡ºé˜Ÿã€‚

> ï¼ˆçœŸå®å·¥ä¸šé‡Œä¼šç”¨æˆç†Ÿåº“ï¼š`concurrent_queue`ã€`boost::lockfree::queue`ï¼Œè¿™é‡Œæˆ‘ä»¬å†™ä¸ªç®€å• demo æ–¹ä¾¿ç†è§£ï¼‰

---

# ğŸ§‘â€ğŸ’» LockFreeQueue.h

```cpp
#pragma once
#include <atomic>
#include <vector>
#include <optional>

template <typename T>
class LockFreeQueue {
public:
    explicit LockFreeQueue(size_t capacity)
        : buffer(capacity), capacity(capacity), head(0), tail(0) {}

    bool push(const T& item) {
        size_t t = tail.load(std::memory_order_relaxed);
        size_t next = (t + 1) % capacity;
        if (next == head.load(std::memory_order_acquire)) {
            return false; // é˜Ÿåˆ—æ»¡
        }
        buffer[t] = item;
        tail.store(next, std::memory_order_release);
        return true;
    }

    std::optional<T> pop() {
        size_t h = head.load(std::memory_order_relaxed);
        if (h == tail.load(std::memory_order_acquire)) {
            return std::nullopt; // é˜Ÿåˆ—ç©º
        }
        T item = buffer[h];
        head.store((h + 1) % capacity, std::memory_order_release);
        return item;
    }

    bool empty() const {
        return head.load() == tail.load();
    }

private:
    std::vector<T> buffer;
    size_t capacity;
    std::atomic<size_t> head;
    std::atomic<size_t> tail;
};
```

---

# ğŸ§‘â€ğŸ’» main.cppï¼ˆæ— é”å¹¶è¡Œ BFSï¼‰

```cpp
#include "ThreadPool.h"
#include "Graph.h"
#include "LockFreeQueue.h"
#include <iostream>
#include <future>
#include <unordered_set>
#include <atomic>
#include <thread>

int main() {
    Graph g;
    // æ„å»ºä¸€ä¸ªå›¾ï¼ˆç¯+é¢å¤–è¾¹ï¼‰
    for (int i = 0; i < 10; i++) g.addEdge(i, (i + 1) % 10);
    g.addEdge(0, 5);
    g.addEdge(3, 7);

    int start = 0, goal = 7;

    ThreadPool pool(4);
    LockFreeQueue<int> frontier(100);
    std::atomic<bool> found(false);

    std::unordered_set<int> visited;
    std::mutex visited_mtx; // visited ä¾ç„¶è¦ä¿æŠ¤ï¼ˆå¯æ¢æ— é”å“ˆå¸Œè¡¨ï¼‰

    frontier.push(start);
    visited.insert(start);

    while (!frontier.empty() && !found) {
        std::vector<std::future<void>> futures;

        while (auto nodeOpt = frontier.pop()) {
            int node = *nodeOpt;

            futures.push_back(pool.submit([&g, node, goal, &frontier, &visited, &visited_mtx, &found]() {
                for (int nei : g.adj[node]) {
                    if (found) return;

                    std::lock_guard<std::mutex> lock(visited_mtx);
                    if (!visited.count(nei)) {
                        visited.insert(nei);
                        frontier.push(nei);
                        if (nei == goal) {
                            std::cout << "Found goal: " << goal << "\n";
                            found = true;
                        }
                    }
                }
            }));
        }

        for (auto &f : futures) f.get();
    }

    if (!found) {
        std::cout << "Goal not found\n";
    }

    return 0;
}
```

---

# ğŸ” å…³é”®åŒºåˆ«

* **å‰ç‰ˆæœ¬**ï¼š`frontier` ç”¨ `std::queue` + `mutex`ï¼Œé«˜å¹¶å‘ä¸‹é”ç«äº‰ä¸¥é‡ã€‚
* **æ”¹è¿›ç‰ˆ**ï¼š`frontier` ç”¨ **LockFreeQueue**ï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥å‡ ä¹æ— é˜»å¡åœ° `push/pop`ã€‚
* `visited` è¿˜ç”¨ `mutex`ï¼ˆå› ä¸ºå“ˆå¸Œè¡¨çš„æ— é”å®ç°æ¯”è¾ƒå¤æ‚ï¼Œå·¥ä¸šé‡Œä¼šç”¨ concurrent hash mapï¼‰ã€‚

---

# âš¡ æå‡æ•ˆæœ

* å½“å›¾è§„æ¨¡å¤§ã€frontier ä¸­èŠ‚ç‚¹æ•°å¤šæ—¶ï¼š

  * **é”ç‰ˆ BFS**ï¼šå¤šä¸ªçº¿ç¨‹éƒ½åœ¨æŠ¢é”ï¼ŒCPU åˆ©ç”¨ç‡ä¸‹é™ã€‚
  * **æ— é” BFS**ï¼šé˜Ÿåˆ—æ“ä½œå‡ ä¹ä¸é˜»å¡ï¼Œçº¿ç¨‹é—´ç«äº‰æ›´å°ï¼Œæœç´¢é€Ÿåº¦æ›´å¿«ã€‚

---

## å¯¹äº C++ å¤šçº¿ç¨‹æŠ€æœ¯ æˆ‘è¿˜éœ€è¦æŒæ¡å“ªäº›å†…å®¹ å¯¹äºæˆ‘çš„ç®—æ³•æ–¹å‘ ä¸Šè¿°çŸ¥è¯†ç‚¹å¤Ÿç”¨äº†å—ï¼Ÿ

ä½ çš„é—®é¢˜éå¸¸å…³é”® ğŸ‘ï¼Œè¯´æ˜ä½ å·²ç»åœ¨æ€è€ƒã€Œæˆ‘çš„ç›®æ ‡æ˜¯ç®—æ³•ç ”å‘ï¼Œé‚£æˆ‘åœ¨ C++ å¤šçº¿ç¨‹ä¸Šè¦æŒæ¡åˆ°ä»€ä¹ˆæ·±åº¦ï¼Ÿã€ã€‚
æˆ‘å¸®ä½ åˆ† **ä¸‰ä¸ªå±‚æ¬¡** æ¥æ¢³ç†ï¼š

---

## âœ… ç¬¬ä¸€å±‚ï¼šå¿…å¤‡ï¼ˆä½ å·²ç»æŒæ¡æˆ–åœ¨å­¦çš„ï¼‰

è¿™äº›æ˜¯ç®—æ³•æ–¹å‘çš„äººå†™å¤šçº¿ç¨‹ä»£ç æ—¶ **å¿…é¡»æŒæ¡çš„**ï¼Œä½ ç°åœ¨å·²ç»åŸºæœ¬è¦†ç›–äº†ï¼š

* **çº¿ç¨‹ä¸è¿›ç¨‹åŒºåˆ«ã€ä¸Šä¸‹æ–‡åˆ‡æ¢ã€æ—¶é—´ç‰‡** â†’ ç†è§£ä¸ºä»€ä¹ˆå¤šçº¿ç¨‹èƒ½åŠ é€Ÿï¼Œä¹ŸçŸ¥é“ä»£ä»·ã€‚
* **std::thread / std::async / future** â†’ æœ€åŸºç¡€çš„å¤šçº¿ç¨‹æ¥å£ã€‚
* **åŒæ­¥ä¸äº’æ–¥**ï¼š`mutex`ã€`condition_variable`ã€`atomic`ã€‚
* **å†…å­˜æ¨¡å‹ä¸å¯è§æ€§**ï¼ˆvolatileã€cache coherenceã€release/acquireï¼‰ã€‚
* **RAIIã€æ™ºèƒ½æŒ‡é’ˆã€move è¯­ä¹‰ã€lambda** â†’ ä¿è¯ä»£ç å®‰å…¨ç®€æ´ã€‚
* **çº¿ç¨‹æ± **ï¼šæ‰¹é‡ä»»åŠ¡è°ƒåº¦çš„æ ¸å¿ƒå·¥å…·ï¼Œå‡ ä¹æ‰€æœ‰ç®—æ³•å¹¶è¡ŒåŒ–éƒ½èƒ½å¥—è¿›å»ã€‚
* **å…¸å‹æ¨¡å‹**ï¼šå¤šç”Ÿäº§è€…-å¤šæ¶ˆè´¹è€…ã€‚

ğŸ‘‰ åˆ°è¿™é‡Œï¼Œä½ å·²ç»èƒ½å†™å‡ºå·¥ä¸šé‡Œ 70% çš„å¹¶è¡Œç®—æ³•äº†ï¼ˆæ¯”å¦‚æ‰¹é‡å›¾åƒå¤„ç†ã€å¹¶è¡Œ BFSã€æ•°æ®é¢„å¤„ç† pipeline ç­‰ï¼‰ã€‚

---

## ğŸš€ ç¬¬äºŒå±‚ï¼šè¿›é˜¶ï¼ˆé’ˆå¯¹ç®—æ³•æ–¹å‘ï¼Œå¼ºçƒˆæ¨èï¼‰

å¦‚æœä½ è¦åš **é«˜æ€§èƒ½ç®—æ³•ï¼ˆå°¤å…¶æ˜¯å¹¶è¡Œ/åˆ†å¸ƒå¼ï¼‰**ï¼Œéœ€è¦ç»§ç»­æŒæ¡ï¼š

1. **ä»»åŠ¡åˆ’åˆ†ä¸è´Ÿè½½å‡è¡¡**

   * BFS/DFS å¹¶è¡Œ â†’ å¦‚ä½•é¿å…çº¿ç¨‹ç©ºé—²ï¼ˆwork stealingã€ä»»åŠ¡æ‹†åˆ†ï¼‰ã€‚
   * å…¸å‹æ¡ˆä¾‹ï¼šIntel TBBï¼ˆtask-based parallelismï¼‰ã€‚

2. **æ— é”æ•°æ®ç»“æ„**

   * lock-free queue, concurrent hash map
   * ç®—æ³•é‡Œå¸¸è§ï¼šå¹¶è¡Œä¼˜å…ˆé˜Ÿåˆ—ï¼ˆA\* æœç´¢ï¼‰ã€æ— é” BFS frontierã€‚

3. **å¹¶è¡Œç®—æ³•æ¨¡å¼**

   * MapReduceï¼ˆç‹¬ç«‹è®¡ç®— + æ±‡æ€»ï¼‰
   * Scan/Reduce/Prefix sum
   * Pipelineï¼ˆæ•°æ®æµå¹¶è¡Œï¼‰

4. **æ€§èƒ½åˆ†æä¸è°ƒä¼˜**

   * false sharingï¼ˆå¤šä¸ªçº¿ç¨‹å†™ç›¸é‚»å†…å­˜ï¼Œå¯¼è‡´ cache line ç«äº‰ï¼‰ã€‚
   * NUMA æ¶æ„ï¼ˆå¤§å›¾/å¤§çŸ©é˜µåœ¨å¤šæ ¸æœºå™¨ä¸Šçš„è®¿é—®å»¶è¿Ÿå·®å¼‚ï¼‰ã€‚
   * å·¥å…·ï¼š`perf`ã€`valgrind`ã€`VTune`ã€‚

---

## ğŸ§  ç¬¬ä¸‰å±‚ï¼šæ‰©å±•ï¼ˆç®—æ³•ç ”ç©¶æ–¹å‘æ˜¯å¦éœ€è¦ï¼Ÿï¼‰

* **åˆ†å¸ƒå¼å¹¶è¡Œ**ï¼ˆMPIã€gRPCï¼‰ï¼šå¦‚æœç®—æ³•è¦è·‘åœ¨å¤šæœºä¸Šã€‚
* **GPU å¹¶è¡Œ**ï¼ˆCUDA/OpenCLï¼‰ï¼šå¾ˆå¤šç®—æ³•åœ¨ GPU ä¸Šæ›´å¿«ï¼ˆæ·±åº¦å­¦ä¹ ã€å›¾è®¡ç®—ï¼‰ã€‚
* **å¹¶å‘ç¼–ç¨‹æ¨¡å‹**ï¼šActor æ¨¡å‹ï¼ˆErlang/CAFï¼‰ã€CSPï¼ˆGo channelï¼‰ï¼Œæ€ç»´æ–¹å¼ä¼šå½±å“ä½ æ€ä¹ˆè®¾è®¡å¹¶è¡Œç®—æ³•ã€‚

è¿™å±‚ä¸€èˆ¬æ˜¯ã€Œç ”ç©¶å‹/å¤§è§„æ¨¡ç³»ç»Ÿå‹ç®—æ³•ã€æ‰ä¼šç”¨åˆ°ã€‚

---

## ğŸ¯ å¯¹ç®—æ³•æ–¹å‘çš„å»ºè®®

ä½ å®Œå…¨æ²¡å¿…è¦åƒç³»ç»Ÿå·¥ç¨‹å¸ˆé‚£æ ·æŒæ¡â€œçº¿ç¨‹æ± å®ç°çš„æ‰€æœ‰ç»†èŠ‚â€æˆ–è€…â€œæ“ä½œç³»ç»Ÿå†…æ ¸çº§è°ƒåº¦å™¨â€ã€‚
**é‡ç‚¹åœ¨äºï¼šèƒ½ç”¨å¤šçº¿ç¨‹æŠŠç®—æ³•å¹¶è¡ŒåŒ–ï¼Œå¹¶ä¸”é¿å…å¸¸è§çš„é™·é˜±ã€‚**

å¯¹ä½ æ¥è¯´ï¼Œå»ºè®®è·¯çº¿ï¼š

1. å…ˆç”¨ç°æˆçš„çº¿ç¨‹æ± ï¼ŒæŠŠå¸¸è§ç®—æ³•å¹¶è¡ŒåŒ–ï¼ˆå›¾æœç´¢ã€å›¾åƒæ‰¹å¤„ç†ã€æ’åº/çŸ©é˜µè¿ç®—ï¼‰ã€‚
2. å­¦ä¸€äº› **å¹¶è¡Œæ¨¡å¼**ï¼ˆMapReduceã€Pipelineï¼‰ï¼Œè¿™äº›åœ¨ç®—æ³•ç ”ç©¶é‡Œå‡ºç°éå¸¸é¢‘ç¹ã€‚
3. å†å­¦ **æ— é”æ•°æ®ç»“æ„** + **æ€§èƒ½ä¼˜åŒ–**ï¼Œè®©å®ç°æ›´é«˜æ•ˆã€‚

---

ğŸ“Œ æ€»ç»“ä¸€å¥è¯ï¼š
ğŸ‘‰ å¯¹ä½ çš„ç®—æ³•æ–¹å‘è€Œè¨€ï¼Œ**ä½ ç°åœ¨æŒæ¡çš„ + çº¿ç¨‹æ±  + æ— é”æ•°æ®ç»“æ„ + å¹¶è¡Œæ¨¡å¼** å·²ç»èƒ½è¦†ç›– 90% çš„éœ€æ±‚ã€‚
æ›´æ·±çš„ï¼ˆåˆ†å¸ƒå¼/GPUï¼‰çœ‹å…·ä½“ç®—æ³•é¢†åŸŸè¦ä¸è¦æ·±å…¥ã€‚

---

è¦ä¸è¦æˆ‘ç»™ä½ æ•´ç†ä¸€ä»½ **â€œC++ å¹¶è¡Œç®—æ³•å­¦ä¹ è·¯çº¿å›¾ï¼ˆç®—æ³•æ–¹å‘ç‰ˆï¼‰â€**ï¼Œåƒ checklist ä¸€æ ·ï¼Œä½ ç…§ç€å­¦å°±èƒ½é€æ­¥æŒæ¡ï¼Ÿ

å¤ªå¥½äº† ğŸ‘ï¼Œæˆ‘æ¥å¸®ä½ æ•´ç†ä¸€ä»½ **ã€ŠC++ å¹¶è¡Œç®—æ³•å­¦ä¹ è·¯çº¿å›¾ï¼ˆç®—æ³•æ–¹å‘ç‰ˆï¼‰ã€‹**ï¼Œä½ å¯ä»¥å½“ checklist æ¥ç”¨ã€‚

---

# ğŸ“˜ C++ å¹¶è¡Œç®—æ³•å­¦ä¹ è·¯çº¿å›¾ï¼ˆç®—æ³•æ–¹å‘ç‰ˆï¼‰

## ğŸŸ¢ ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€ï¼ˆå¿…å¤‡ï¼‰

ç›®æ ‡ï¼šèƒ½å†™å‡ºåŸºæœ¬çš„å¤šçº¿ç¨‹ç®—æ³•ä»£ç 

* æ“ä½œç³»ç»Ÿå¹¶å‘åŸç†

  * çº¿ç¨‹ vs è¿›ç¨‹
  * ä¸Šä¸‹æ–‡åˆ‡æ¢ / æ—¶é—´ç‰‡è°ƒåº¦
  * å†…å­˜æ¨¡å‹ï¼šç¼“å­˜ä¸€è‡´æ€§ã€å¯è§æ€§
* C++ å¤šçº¿ç¨‹åŸºç¡€

  * `std::thread` åˆ›å»º / join / detach
  * `std::async`ã€`std::future`
  * `std::mutex`ã€`std::unique_lock`ã€`std::condition_variable`
  * `std::atomic` åŸºç¡€ï¼ˆè®¡æ•°å™¨ã€æ ‡å¿—ä½ï¼‰
* C++ è¯­æ³•æ”¯æŒ

  * RAII & æ™ºèƒ½æŒ‡é’ˆï¼ˆçº¿ç¨‹å®‰å…¨èµ„æºç®¡ç†ï¼‰
  * `lambda`ï¼ˆçº¿ç¨‹å›è°ƒå¸¸ç”¨ï¼‰
  * `move` è¯­ä¹‰ï¼ˆä»»åŠ¡å‚æ•°ä¼ é€’ï¼‰

âœ… é˜¶æ®µä»»åŠ¡ï¼š

* å®ç° **å•ç”Ÿäº§è€…å•æ¶ˆè´¹è€…é˜Ÿåˆ—**ï¼ˆmutex+cvï¼‰ã€‚
* å†™ä¸€ä¸ª **å¤šçº¿ç¨‹æ’åº**ï¼ˆæŠŠæ•°ç»„åˆ‡å—ï¼Œåˆ†åˆ«æ’åºï¼Œæœ€ååˆå¹¶ï¼‰ã€‚

---

## ğŸŸ¡ ç¬¬äºŒé˜¶æ®µï¼šå¹¶è¡Œæ¨¡å¼ï¼ˆè¿›é˜¶ï¼‰

ç›®æ ‡ï¼šå­¦ä¼šæŠŠç®—æ³•æ˜ å°„åˆ°åˆé€‚çš„å¹¶è¡Œæ¨¡å¼

* å¤šç”Ÿäº§è€…-å¤šæ¶ˆè´¹è€…æ¨¡å‹
* çº¿ç¨‹æ± ï¼ˆä»»åŠ¡è°ƒåº¦æ ¸å¿ƒå·¥å…·ï¼‰
* å¸¸è§å¹¶è¡Œç®—æ³•æ¨¡å¼ï¼š

  * **MapReduce**ï¼ˆä»»åŠ¡æ‹†åˆ†+ç»“æœæ±‡æ€»ï¼‰
  * **Pipeline**ï¼ˆæµæ°´çº¿ï¼Œæ¯”å¦‚å›¾åƒé¢„å¤„ç† â†’ ç‰¹å¾æå– â†’ å­˜å‚¨ï¼‰
  * **Scan / Reduce / Prefix Sum**ï¼ˆå¾ˆå¤šå›¾ç®—æ³• & æ•°å€¼è®¡ç®—ä¾èµ–ï¼‰
* æ— é”ç¼–ç¨‹å…¥é—¨

  * lock-free queue
  * ABA é—®é¢˜ä¸ CAS

âœ… é˜¶æ®µä»»åŠ¡ï¼š

* ç”¨ **çº¿ç¨‹æ± ** åŠ é€Ÿæ‰¹é‡å›¾åƒå¤„ç†ã€‚
* å¹¶è¡Œ BFSï¼ˆå…ˆç”¨ mutexï¼Œå†å°è¯• lock-free queueï¼‰ã€‚
* å†™ä¸€ä¸ª **å¹¶è¡ŒçŸ©é˜µä¹˜æ³•**ï¼ˆåˆ†å—è®¡ç®—ï¼‰ã€‚

---

## ğŸ”´ ç¬¬ä¸‰é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆé«˜é˜¶ï¼‰

ç›®æ ‡ï¼šå†™å‡ºçš„å¹¶è¡Œç®—æ³•ä¸ä»…èƒ½è·‘ï¼Œè¿˜èƒ½å¿«

* false sharingï¼ˆé¿å…å¤šä¸ªçº¿ç¨‹å†™åŒä¸€ cache lineï¼‰
* NUMA æ¶æ„ï¼ˆè·¨ CPU èŠ‚ç‚¹å†…å­˜è®¿é—®ä»£ä»·ï¼‰
* work stealing / ä»»åŠ¡çªƒå–è°ƒåº¦
* Profiling å·¥å…·

  * Linux: `perf`, `htop`, `valgrind`
  * Intel: VTune
* é«˜æ€§èƒ½å¹¶è¡Œåº“

  * Intel TBBï¼ˆtask-basedï¼Œè´Ÿè½½å‡è¡¡å¥½ï¼‰
  * OpenMPï¼ˆå¾ªç¯/æ•°å€¼è®¡ç®—å¹¶è¡ŒåŒ–ç®€å•ï¼‰

âœ… é˜¶æ®µä»»åŠ¡ï¼š

* å®ç° **å¹¶è¡Œ Dijkstra/A**\*ï¼ˆéœ€è¦å¹¶è¡Œä¼˜å…ˆé˜Ÿåˆ—ï¼‰ã€‚
* å¯¹æ¯” **é”ç‰ˆ vs æ— é”ç‰ˆ BFS** çš„æ€§èƒ½å·®å¼‚ï¼ˆç”¨ `perf` æµ‹è¯•ï¼‰ã€‚

---

## ğŸŸ£ ç¬¬å››é˜¶æ®µï¼šæ‰©å±•ï¼ˆæŒ‰éœ€å­¦ä¹ ï¼‰

ç›®æ ‡ï¼šé¢å‘æ›´å¤§è§„æ¨¡ / æ›´ä¸“ä¸šé¢†åŸŸ

* åˆ†å¸ƒå¼å¹¶è¡Œ

  * MPIï¼ˆå¤šæœºå¤šè¿›ç¨‹ï¼‰
  * gRPCï¼ˆè·¨èŠ‚ç‚¹é€šä¿¡ï¼‰
* GPU å¹¶è¡Œ

  * CUDAï¼ˆå›¾åƒã€çŸ©é˜µã€æ·±åº¦å­¦ä¹ ï¼‰
  * OpenCLï¼ˆè·¨å¹³å° GPUï¼‰
* å¹¶å‘ç¼–ç¨‹æ¨¡å‹

  * Actor æ¨¡å‹ï¼ˆæ¶ˆæ¯é©±åŠ¨ï¼Œé€‚åˆå¤æ‚ç³»ç»Ÿï¼‰
  * CSPï¼ˆchannel é€šä¿¡ï¼ŒGo çš„æ€ç»´æ–¹å¼ï¼‰

âœ… é˜¶æ®µä»»åŠ¡ï¼š

* å¦‚æœåšå›¾ç®—æ³•ï¼Œå¯ä»¥è¯•è¯• **GPU åŠ é€Ÿ BFS**ã€‚
* å¦‚æœåšåˆ†å¸ƒå¼å›¾è®¡ç®—ï¼Œå¯ä»¥å­¦ä¹  **Pregel / GraphX** æ¨¡å‹ã€‚

---

# ğŸ¯ æ€»ç»“

* **ç¬¬ä¸€ã€äºŒé˜¶æ®µ** â†’ è¶³å¤Ÿæ”¯æ’‘ä½ åœ¨ç®—æ³•æ–¹å‘å†™å‡ºé«˜æ•ˆå¹¶è¡Œç®—æ³•ã€‚
* **ç¬¬ä¸‰é˜¶æ®µ** â†’ è¿›å…¥æ€§èƒ½ä¼˜åŒ–é¢†åŸŸï¼Œè®©ç®—æ³•è·‘å¾—æ›´å¿«æ›´ç¨³ã€‚
* **ç¬¬å››é˜¶æ®µ** â†’ è§†æ–¹å‘å†³å®šæ˜¯å¦æ·±å…¥ï¼ˆæ¯”å¦‚ä½ åš GPU ç®—æ³•å°±å¿…é¡»å­¦ CUDAï¼‰ã€‚

---

ğŸ“Œ å»ºè®®å­¦ä¹ é¡ºåºï¼š
**åŸºç¡€ â†’ å¹¶è¡Œæ¨¡å¼ â†’ ä¼˜åŒ– â†’ æ‰©å±•**
æ¯ä¸ªé˜¶æ®µéƒ½å†™å‡ ä¸ªå° demoï¼Œä¿è¯â€œèƒ½ç”¨ã€èƒ½è·‘ã€èƒ½ä¼˜åŒ–â€ã€‚

---

è¦ä¸è¦æˆ‘å¸®ä½ æŠŠè¿™äº›é˜¶æ®µé…ä¸Šä¸€äº› **å…·ä½“çš„ GitHub å¼€æºé¡¹ç›®æ¨è**ï¼ˆæ¯é˜¶æ®µ 2\~3 ä¸ªå­¦ä¹ ç”¨ä¾‹ï¼‰ï¼Ÿè¿™æ ·ä½ èƒ½ä¸€è¾¹çœ‹åˆ«äººä»£ç ä¸€è¾¹ç»ƒä¹ ã€‚
