🧪 实验 2：线程之间 共享内存

在 C++11 标准里用 std::thread，两个线程修改同一个 counter。

👉 两个线程操作的 counter 是同一份内存，所以最后结果是 叠加的。

⚠️ 如果你多跑几次，可能出现“乱序输出”，因为没有加锁时存在 竞争条件（data race）。

🔑 对比总结

- 进程：各自独立 → 变量不共享（例子 1）

- 线程：共享同一内存 → 变量会相互影响（例子 2）
  
要不要我帮你再加一个 线程加锁版（用 mutex 保证输出稳定），这样你能直观对比“有锁”和“无锁”的差别？