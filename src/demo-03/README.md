🧪 实验 3：线程加锁版（使用 std::mutex）

👉 因为用了 std::lock_guard<std::mutex>，保证了同一时刻只有一个线程能修改 counter，所以不会出现数据竞争，最终结果是可预测的。

🔑 对比回顾

无锁版：两个线程可能同时写 counter，结果可能错乱（比如丢加）。

有锁版：强制互斥访问 → 输出顺序可控，结果稳定。

要不要我再帮你扩展一个 条件变量版（生产者-消费者） 的例子？那是多线程同步协作的经典场景，比加锁更直观。